#!/usr/bin/env ruby

require 'rubygems'
require 'thor'
require 'bundler'
require 'mccloud'
require 'mccloud/generators'
require 'mccloud/config'
require 'mccloud/ssh'
require 'mccloud/util/platform'
require 'fog'
require 'pp'
require 'net/scp'

PROVIDER=Fog::Compute.new(:provider => 'AWS')

class MccloudCLI < Thor 
  
  attr_accessor :all_servers
  no_tasks do
	  def load_config
		#if File.exist?(path)
		Kernel.load File.join(Dir.pwd,"Mccloudfile")
		@all_servers=Hash.new
		PROVIDER.servers.each do |vm|
			@all_servers[vm.tags["Name"]]=vm.id	
		end
	  end
	  def on_selected_machines(selection)
	        if selection.nil?
			Mccloud::Config.config.vms.each do |vm|
				name=vm.name
				prefix=Mccloud::Config.config.mccloud.prefix
				id=all_servers["#{prefix} - #{name}"]
				vm=Mccloud::Config.config.vms[name]
				yield id,vm
			end
		else
			name=selection
			prefix=Mccloud::Config.config.mccloud.prefix
			id=all_servers["#{prefix} - #{name}"]
			vm=Mccloud::Config.config.vms[name]
			yield id,vm
		end
	  end
  end

  desc "init [AMI-ID]", "initializes a box from a template" 
  method_options :force => :boolean
  def init(amiId=nil)
	load_config
	Mccloud::Generators.run_cli Dir.pwd, File.basename(__FILE__), Mccloud::VERSION, ARGV
  end

  desc "templates", "list amis available" 
  def templates(query=nil)
	load_config
    Mccloud::CLI.list_templates(query)
  end
  
  desc "up", "bring a machine up"
  method_options :force => :boolean
  def up(selection=nil)
	load_config
	Mccloud::Config.config.vms.each do |vm|
		provider=vm.provider
		provider_options=vm.provider_options
		boxname=vm.name
		prefix=Mccloud::Config.config.mccloud.prefix
		if selection.nil?
			server= PROVIDER.servers.create(provider_options)
			PROVIDER.create_tags(server.id, { "Name" => "#{prefix} - #{boxname}"})
		else
			if boxname==selection
				PROVIDER.create_tags(server.id, { "Name" => "#{prefix} - #{boxname}"})
			end
		end
	end
  end

  desc "suspend", "freeze"
  method_options :force => :boolean
  def suspend(selection=nil)
	load_config
	on_selected_machines(selection) do |id|
		puts "halting #{id}"
		PROVIDER.servers.get(id).stop
	end
  end

  desc "boot", "freeze"
  method_options :force => :boolean
  def boot(selection=nil)
	load_config
	on_selected_machines(selection) do |id|
		puts "starting #{id}"
		PROVIDER.servers.get(id).start
	end
  end


  desc "halt [NAME]", "shutdown the machine"
  method_options :force => :boolean  
  def halt(selection=nil)
	load_config
	on_selected_machines(selection) do |id|
		puts "halting #{id}"
		PROVIDER.servers.get(id).stop
	end
  end

  desc "destroy [NAME]", "destroys the machine"
  method_options :force => :boolean  
  def destroy(selection=nil)
	load_config
	on_selected_machines(selection) do |id|
		puts "destroying #{id}"
		PROVIDER.servers.get(id).destroy
	end
  end

  desc "reload [NAME]", "reloads the machine"
  method_options :force => :boolean  
  def reload(selection=nil?)
	load_config
	on_selected_machines(selection) do |id|
		puts "rebooting #{id}"
		PROVIDER.servers.get(id).reboot
	end
  end

  desc "ssh [NAME]", "spawns an ssh to the machine"
  method_options :force => :boolean  
  def ssh(selection)
	load_config
	name=selection
	prefix=Mccloud::Config.config.mccloud.prefix
	id=all_servers["#{prefix} - #{name}"]

	instance=PROVIDER.servers.get(id)
	vm=Mccloud::Config.config.vms[name]

	#https://github.com/mitchellh/vagrant/blob/master/lib/vagrant/ssh.rb
	options={ :port => 22, :private_key_path => vm.key, 
		:username => vm.user , :host => instance.public_ip_address }
      # Command line options
      command_options = ["-p #{options[:port]}", "-o UserKnownHostsFile=/dev/null",
                         "-o StrictHostKeyChecking=no", "-o IdentitiesOnly=yes",
                         "-i #{options[:private_key_path]}"]
      # Some hackery going on here. On Mac OS X Leopard (10.5), exec fails
      # (GH-51). As a workaround, we fork and wait. On all other platforms,
      # we simply exec.
      pid = nil
      pid = fork if Mccloud::Util::Platform.leopard? || Mccloud::Util::Platform.tiger?
      Kernel.exec "ssh #{command_options.join(" ")} #{options[:username]}@#{options[:host]}".strip if pid.nil?
      Process.wait(pid) if pid
  end

  desc "command [NAME] [COMMAND]", "exec a command on a box"
  def command(selection,command="who am i")
	load_config
	on_selected_machines(selection) do |id,vm|
		server=PROVIDER.servers.get(id)
		server.private_key_path=vm.key
		server.username = vm.user
		result=server.ssh(command)
		puts result[0].stdout
	end
  end

  desc "bootstrap [NAME]", "exec a command on a box"
  def bootstrap(selection,command="who am i")
	load_config
	on_selected_machines(selection) do |id,vm|
		server=PROVIDER.servers.get(id)
		server.private_key_path=vm.key
		server.username = vm.user
		server.scp(vm.bootstrap,"/tmp/bootstrap.sh")
		result=server.ssh("chmod +x /tmp/bootstrap.sh")
		instance=PROVIDER.servers.get(id)
		options={ :port => 22, :keys => [ vm.key ], :paranoid => false, :keys_only => true}
		Mccloud::Ssh.execute(instance.public_ip_address,vm.user,options,"sudo /tmp/bootstrap.sh")
	end
  end


  desc "status", "status"
  method_options :force => :boolean  
  def status
	load_config
	Kernel.load File.join(Dir.pwd,"Mccloudfile")
	printf "%-40s %-41s %-12s %-20s %-10s\n", "Name", "Public Name", "Instance Id", "IP", "Type"
	159.times { |i| printf "=" } ; puts
	PROVIDER.servers.each do |vm|
		printf "%-40s %-41s %-12s %-20s %-10s %-10s\n", vm.tags["Name"].strip, vm.dns_name,vm.id, vm.public_ip_address, vm.flavor.name,vm.state
	end
  end

  desc "provision ", "provision the machine"
  def provision(selection=nil?)
	load_config
	on_selected_machines(selection) do |id,vm|
		instance=PROVIDER.servers.get(id)
		options={ :port => 22, :keys => [ vm.key ], :paranoid => false, :keys_only => true}
		Mccloud::Ssh.execute(instance.public_ip_address,vm.user,options,"who am i")
	end
  end

end

MccloudCLI.start

